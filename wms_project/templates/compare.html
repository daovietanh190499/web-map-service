<!DOCTYPE html>
<html>
<head>
    <title>Leaflet Split Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="static/css/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="static/css/leaflet.css" />
    <link href="static/css/fa.min.css" rel="stylesheet">
    <link rel="stylesheet" href="static/css/leaflet-layer-tree-control.css" />
    <script src="static/js/tailwind.js"></script>
    <link rel="stylesheet" href="static/css/easy-button.css">
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        #container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }
        #map1, #map2 {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .divider {
            position: absolute;
            width: 4px;
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            cursor: col-resize;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
        }
        .divider::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }
        .divider::before {
            content: '↔';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            font-size: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <!-- Login Modal -->
    <div id="loginModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 hidden z-50">
        <div class="flex items-center justify-center min-h-screen">
            <div class="bg-white rounded-lg shadow-xl p-6 w-96">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-900">Đăng nhập</h3>
                    <button id="closeLoginModal" class="text-gray-400 hover:text-gray-600">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <form id="loginForm">
                    <div class="mb-4">
                        <label for="username" class="block text-sm font-medium text-gray-700 mb-2">Tên đăng nhập</label>
                        <input type="text" id="username" name="username" required 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="mb-6">
                        <label for="password" class="block text-sm font-medium text-gray-700 mb-2">Mật khẩu</label>
                        <input type="password" id="password" name="password" required 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <div class="flex items-center justify-between">
                        <button type="submit" 
                                class="w-full bg-blue-600 text-white py-2 px-4 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            Đăng nhập
                        </button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Login Button -->
    <div class="fixed top-4 left-4 z-40">
        <button id="loginBtn" class="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <i class="fas fa-user mr-2"></i>Đăng nhập
        </button>
    </div>

    <div id="container">
        <div id="map1"></div>
        <div class="divider"></div>
        <div id="map2"></div>
    </div>

    <script src="static/js/leaflet.js"></script>
    <script src="static/js/leaflet.draw.js"></script>
    <link rel="stylesheet" href="static/css/leaflet.draw.css"></script>
    <script src="static/js/leaflet-layer-tree-control.js"></script>
    <script src="static/js/leaflet-layer-tree-control-wfs-zoom.js"></script>
    <script src="static/js/easy-button.js"></script>
    <script>
        function getListLayer() {
            let list_layer = JSON.parse(window.localStorage.getItem("layers"));
            if (!list_layer) {
                list_layer = {}
            }
            return list_layer
        }

        // Initialize maps
        const map1 = L.map('map1', { zoomControl: false }).setView([21.148023790045897, 105.62239681777376], 13);
        const map2 = L.map('map2', { zoomControl: false }).setView([21.148023790045897, 105.62239681777376], 13);

        L.control.zoom({
            position: 'bottomleft'
        }).addTo(map1);

        L.control.zoom({
            position: 'bottomright'
        }).addTo(map2);

        L.easyButton('fa-home', function(btn, map){
            window.location.replace('/')
        }, "Go Home", {position: "bottomright"}).addTo(map2);

        var theLeftTreeControl

        // Initialize the layer tree
        (async function() {
            await updateLeftLayerTree()
        })()

        async function updateLeftLayerTree() {
            if (theLeftTreeControl) {
                theLeftTreeControl.remove(map);
            }

            let list_layer = getListLayer()

            var layerBuilders = {}
            let basemaps = []

            // Load basemap configuration
            try {
                const response = await fetch('/api/basemaps/');
                const basemapsData = await response.json();
                basemaps = basemapsData.results || basemapsData;
                
                // Add dynamic layer builders from basemaps
                basemaps.forEach(basemap => {
                    layerBuilders[basemap.service_type] = function(layerSettings) {
                        const options = {
                            attribution: basemap.attribution
                        };
                        
                        if (basemap.subdomains && basemap.subdomains.length > 0) {
                            options.subdomains = basemap.subdomains;
                        }
                        
                        return L.tileLayer(basemap.url, options);
                    };
                });
                
                // Add default layer builders if no basemaps are configured
                if (basemaps.length === 0) {
                    layerBuilders.OSM = function(layerSettings) {
                        return L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                            subdomains: ['a', 'b', 'c']
                        });
                    };
                    
                    layerBuilders.SATELLITE = function(layerSettings) {
                        return L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                            attribution: 'Tiles © Esri'
                        });
                    };
                }
            } catch (error) {
                console.error('Error loading basemap configuration:', error);
                // Fallback to default layer builders
                layerBuilders.OSM = function(layerSettings) {
                    return L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        subdomains: ['a', 'b', 'c']
                    });
                };
                
                layerBuilders.SATELLITE = function(layerSettings) {
                    return L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles © Esri'
                    });
                };
            }

            for (let layer in list_layer) {
                layerBuilders[layer] = function(layerSettings) { 
                    return L.tileLayer(`api/images/${layer}/jp2/tiles/{z}/{x}/{y}.png/`, {
                        maxZoom: 20,
                        attribution: `${layer} JP2 Layer`
                    });
                }
            }

            theLeftTreeControl = new L.Control.LayerTreeControl({
                // layerTree: rootLayerSettings,
                position: 'topleft',
                openByDefault: true,
                layerBuilders: layerBuilders,
                featureBuilders: {
                    WFS: {
                        zoom: L.Control.LayerTreeControl.WFSZoomFeature
                    }
                }
            }).addTo(map1);

            var rootLayerId = theLeftTreeControl.addLayerDynamically({
                code: "root",
                name: "All the Layers",
                active: true,
                selectedByDefault: false,
                openByDefault: true,
                childLayers: [],
                selectType: "NONE",
                serviceType: null,
                params: {}
            });

            var baseLayerId = theLeftTreeControl.addLayerDynamically({
                code: "base",
                name: "Base layers",
                active: true,
                selectedByDefault: false,
                openByDefault: true,
                childLayers: [],
                selectType: "SINGLE",
                serviceType: null,
                params: {}
            }, rootLayerId);

            var overlaysLayerId = theLeftTreeControl.addLayerDynamically({
                code: "overlays",
                name: "Overlays",
                active: true,
                selectedByDefault: false,
                openByDefault: true,
                childLayers: [],
                selectType: "MULTIPLE",
                serviceType: null,
                params: {}
            }, rootLayerId);

            // Add dynamic basemap layers
            basemaps.forEach((basemap, index) => {
                theLeftTreeControl.addLayerDynamically({
                    code: basemap.service_type.toLowerCase(),
                    name: basemap.service_type,
                    active: true,
                    selectedByDefault: index === 0, // First one is selected by default
                    openByDefault: true,
                    childLayers: [],
                    selectType: "NONE",
                    serviceType: basemap.service_type,
                    params: {}
                }, baseLayerId);
            });

            // If no basemaps configured, add defaults
            if (basemaps.length === 0) {
                theLeftTreeControl.addLayerDynamically({
                    code: "osm",
                    name: "OpenStreetMap",
                    active: true,
                    selectedByDefault: true,
                    openByDefault: true,
                    childLayers: [],
                    selectType: "NONE",
                    serviceType: "OSM",
                    params: {}
                }, baseLayerId);

                theLeftTreeControl.addLayerDynamically({
                    code: "satellite",
                    name: "Satellite",
                    active: true,
                    selectedByDefault: false,
                    openByDefault: true,
                    childLayers: [],
                    selectType: "NONE",
                    serviceType: "SATELLITE",
                    params: {}
                }, baseLayerId);
            }
            
            for (let layer in list_layer) {
                let coords = list_layer[layer]['coords'][0]
                theLeftTreeControl.addLayerDynamically({
                    code: layer,
                    name: list_layer[layer]['name'] ? list_layer[layer]['name'] : layer,
                    active: true,
                    selectedByDefault: false,
                    openByDefault: true,
                    childLayers: [],
                    coord: [(coords[2][1] + coords[0][1])/2, (coords[0][0] + coords[2][0])/2],
                    selectType: "NONE",
                    serviceType: layer,
                    params: {}
                }, overlaysLayerId);
            }
        }

        var theRightTreeControl

        // Initialize the right layer tree
        (async function() {
            await updateRightLayerTree()
        })()

        async function updateRightLayerTree() {
            if (theRightTreeControl) {
                theRightTreeControl.remove(map);
            }

            let list_layer = getListLayer()

            var layerBuilders = {}
            let basemaps = []

            // Load basemap configuration
            try {
                const response = await fetch('/api/basemaps/');
                const basemapsData = await response.json();
                basemaps = basemapsData.results || basemapsData;
                
                // Add dynamic layer builders from basemaps
                basemaps.forEach(basemap => {
                    layerBuilders[basemap.service_type] = function(layerSettings) {
                        const options = {
                            attribution: basemap.attribution
                        };
                        
                        if (basemap.subdomains && basemap.subdomains.length > 0) {
                            options.subdomains = basemap.subdomains;
                        }
                        
                        return L.tileLayer(basemap.url, options);
                    };
                });
                
                // Add default layer builders if no basemaps are configured
                if (basemaps.length === 0) {
                    layerBuilders.OSM = function(layerSettings) {
                        return L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                            subdomains: ['a', 'b', 'c']
                        });
                    };
                    
                    layerBuilders.SATELLITE = function(layerSettings) {
                        return L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                            attribution: 'Tiles © Esri'
                        });
                    };
                }
            } catch (error) {
                console.error('Error loading basemap configuration:', error);
                // Fallback to default layer builders
                layerBuilders.OSM = function(layerSettings) {
                    return L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                        subdomains: ['a', 'b', 'c']
                    });
                };
                
                layerBuilders.SATELLITE = function(layerSettings) {
                    return L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                        attribution: 'Tiles © Esri'
                    });
                };
            }

            for (let layer in list_layer) {
                layerBuilders[layer] = function(layerSettings) { 
                    return L.tileLayer(`api/images/${layer}/jp2/tiles/{z}/{x}/{y}.png/`, {
                        maxZoom: 20,
                        attribution: `${layer} JP2 Layer`
                    });
                }
            }

            theRightTreeControl = new L.Control.LayerTreeControl({
                // layerTree: rootLayerSettings,
                openByDefault: true,
                layerBuilders: layerBuilders,
                featureBuilders: {
                    WFS: {
                        zoom: L.Control.LayerTreeControl.WFSZoomFeature
                    }
                }
            }).addTo(map2);

            var rootLayerId = theRightTreeControl.addLayerDynamically({
                code: "root",
                name: "All the Layers",
                active: true,
                selectedByDefault: false,
                openByDefault: true,
                childLayers: [],
                selectType: "NONE",
                serviceType: null,
                params: {}
            });

            var baseLayerId = theRightTreeControl.addLayerDynamically({
                code: "base",
                name: "Base layers",
                active: true,
                selectedByDefault: false,
                openByDefault: true,
                childLayers: [],
                selectType: "SINGLE",
                serviceType: null,
                params: {}
            }, rootLayerId);

            var overlaysLayerId = theRightTreeControl.addLayerDynamically({
                code: "overlays",
                name: "Overlays",
                active: true,
                selectedByDefault: false,
                openByDefault: true,
                childLayers: [],
                selectType: "MULTIPLE",
                serviceType: null,
                params: {}
            }, rootLayerId);

            // Add dynamic basemap layers
            basemaps.forEach((basemap, index) => {
                theRightTreeControl.addLayerDynamically({
                    code: basemap.service_type.toLowerCase(),
                    name: basemap.service_type,
                    active: true,
                    selectedByDefault: index === 0, // First one is selected by default
                    openByDefault: true,
                    childLayers: [],
                    selectType: "NONE",
                    serviceType: basemap.service_type,
                    params: {}
                }, baseLayerId);
            });

            // If no basemaps configured, add defaults
            if (basemaps.length === 0) {
                theRightTreeControl.addLayerDynamically({
                    code: "osm",
                    name: "OpenStreetMap",
                    active: true,
                    selectedByDefault: true,
                    openByDefault: true,
                    childLayers: [],
                    selectType: "NONE",
                    serviceType: "OSM",
                    params: {}
                }, baseLayerId);

                theRightTreeControl.addLayerDynamically({
                    code: "satellite",
                    name: "Satellite",
                    active: true,
                    selectedByDefault: false,
                    openByDefault: true,
                    childLayers: [],
                    selectType: "NONE",
                    serviceType: "SATELLITE",
                    params: {}
                }, baseLayerId);
            }
            
            for (let layer in list_layer) {
                let coords = list_layer[layer]['coords'][0]
                theRightTreeControl.addLayerDynamically({
                    code: layer,
                    name: list_layer[layer]['name'] ? list_layer[layer]['name'] : layer,
                    active: true,
                    selectedByDefault: false,
                    openByDefault: true,
                    childLayers: [],
                    coord: [(coords[2][1] + coords[0][1])/2, (coords[0][0] + coords[2][0])/2],
                    selectType: "NONE",
                    serviceType: layer,
                    params: {}
                }, overlaysLayerId);
            }
        }

        // Sync maps for continuous view
        function syncMaps(sourceMap, targetMap) {
            sourceMap.on('move', function() {
                targetMap.setView(sourceMap.getCenter(), sourceMap.getZoom(), {
                    animate: false
                });
            });
        }

        syncMaps(map1, map2);
        syncMaps(map2, map1);

        // Resizable divider functionality
        const container = document.getElementById('container');
        const divider = document.querySelector('.divider');
        const map1Div = document.getElementById('map1');
        const map2Div = document.getElementById('map2');

        let isDragging = false;

        divider.addEventListener('mousedown', function(e) {
            isDragging = true;
            e.preventDefault();
        });

        document.addEventListener('mousemove', function(e) {
            if (!isDragging) return;

            const containerRect = container.getBoundingClientRect();
            const x = e.clientX - containerRect.left;
            const containerWidth = containerRect.width;

            // Calculate percentages
            const leftPercentage = (x / containerWidth) * 100;

            // Limit the minimum size of each map to 20%
            if (leftPercentage >= 20 && leftPercentage <= 80) {
                divider.style.left = leftPercentage + '%';

                // Adjust map positions using clip-path
                map1Div.style.clipPath = `inset(0 ${100 - leftPercentage}% 0 0)`;
                map2Div.style.clipPath = `inset(0 0 0 ${leftPercentage}%)`;

                map1.invalidateSize();
                map2.invalidateSize();
            }
        });

        function init() {

          const containerRect = container.getBoundingClientRect();
          const x = e.clientX - containerRect.left;
          const containerWidth = containerRect.width;

          // Calculate percentages
          const leftPercentage = (x / containerWidth) * 100;

          // Limit the minimum size of each map to 20%
          if (leftPercentage >= 20 && leftPercentage <= 80) {
              divider.style.left = leftPercentage + '%';

              // Adjust map positions using clip-path
              map1Div.style.clipPath = `inset(0 ${100 - leftPercentage}% 0 0)`;
              map2Div.style.clipPath = `inset(0 0 0 ${leftPercentage}%)`;

              map1.invalidateSize();
              map2.invalidateSize();
          }
        }

        // init()

        document.addEventListener('mouseup', function() {
            isDragging = false;
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            map1.invalidateSize();
            map2.invalidateSize();
        });

        // Login Modal Functionality
        const loginModal = document.getElementById('loginModal');
        const loginBtn = document.getElementById('loginBtn');
        const closeLoginModal = document.getElementById('closeLoginModal');

        loginBtn.addEventListener('click', function() {
            loginModal.classList.remove('hidden');
        });

        closeLoginModal.addEventListener('click', function() {
            loginModal.classList.add('hidden');
        });

        // Close modal when clicking outside
        loginModal.addEventListener('click', function(e) {
            if (e.target === loginModal) {
                loginModal.classList.add('hidden');
            }
        });

        // Handle login form submission
        document.getElementById('loginForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            
            fetch('/api/auth/login/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                },
                body: JSON.stringify({
                    username: username,
                    password: password
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.message) {
                    alert('Đăng nhập thành công!');
                    loginModal.classList.add('hidden');
                    // Reload page to update login state
                    window.location.reload();
                } else if (data.error) {
                    alert('Đăng nhập thất bại: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Có lỗi xảy ra khi đăng nhập.');
            });
        });

        // Function to update login state
        function updateLoginState(isLoggedIn, user = null) {
            const loginBtn = document.getElementById('loginBtn');
            if (isLoggedIn && user) {
                loginBtn.innerHTML = `<i class="fas fa-user-check mr-2"></i>${user.username}`;
                loginBtn.onclick = function() {
                    // Show user menu or logout
                    if (confirm('Bạn có muốn đăng xuất?')) {
                        logout();
                    }
                };
            } else {
                loginBtn.innerHTML = `<i class="fas fa-user mr-2"></i>Đăng nhập`;
                loginBtn.onclick = function() {
                    loginModal.classList.remove('hidden');
                };
            }
        }

        // Logout function
        function logout() {
            fetch('/api/auth/logout/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCSRFToken()
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.message) {
                    alert('Đăng xuất thành công!');
                    updateLoginState(false);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                alert('Có lỗi xảy ra khi đăng xuất.');
            });
        }

        // CSRF Token helper function - get from cookie
        function getCSRFToken() {
            // Try to get from cookie first
            const cookies = document.cookie.split(';');
            for (let cookie of cookies) {
                const [name, value] = cookie.trim().split('=');
                if (name === 'csrftoken') {
                    return value;
                }
            }
            // Fallback to DOM if cookie not found
            const tokenElement = document.querySelector('[name=csrfmiddlewaretoken]');
            if (tokenElement) {
                return tokenElement.value;
            }
            // If still not found, try to get from meta tag
            const metaToken = document.querySelector('meta[name=csrf-token]');
            if (metaToken) {
                return metaToken.getAttribute('content');
            }
            throw new Error('CSRF token not found');
        }

        // Check if user is already logged in
        fetch('/api/auth/user/')
            .then(response => response.json())
            .then(data => {
                if (data.user) {
                    updateLoginState(true, data.user);
                }
            })
            .catch(error => {
                console.log('User not logged in');
            });
    </script>
</body>
</html>
